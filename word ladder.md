# 126 / 127. Word Ladder
## 无向无权图的最短路径.

### 问题介绍
单词接龙-- beginWord -> [wordlist] -> endWord.    
127: 找最短路径的长度    
126: 找最小长度下的所有路径

## 127 
### 思考 
问题可以抽象为无向无权图(an undirected and unweighted graph):
* 单词 - nodes
* 只有一个字母之差 - edges.  
该问题变成找到从起点到终点的最短路径(无权图). 因此可以用BFS, 第一次到达即为最短路径.   

### 预处理
构造一个单词变换的通用状态. 例如：dog -> d*g <- dig. 
这样可以通过单词表中所有单词改变某个字母后的通用状态, 快速找出其相邻节点. (节省大量遍历单词表的时间.) 这项预处理操作等价于BFS中高效的邻接表.

例如, 在BFS时我们需要访问dog的所有邻接点, 可以先生成其所有通用状态: 
* dog => *og
* dog => d*g
* dog => do*     
 
第二个变换 d*g 可以同时映射到 dig 或者 dug, 因为他们都有相同的通用状态. 拥有相同的通用状态意味着两个单词只相差一个字母, 即他们的节点是相连的。

### 法1: 单向广度优先搜索(Breadth First Search)
#### 算法
1. 对 [wordlist] 预处理, 并储存为词典. eg: `dict('d*g') = set('dig','dug') `
2. 新建queue,初始元素(beginWord,1), 1 表示 detpth = 1. 最后返回的endWord 的depth就是最短距离. 
3. 队列非空时, 取出第一个元素: current_word.
4. 找到 current_word 的所有通用状态. 并找到通用状态下的所有**未遍历**过的单词(邻接点),加入队列. eg: `queue.append((dig,depth+1))` 
5. 到达 endWord => 返回 depth; queue 空 => 不存在这样的路径,返回 0. 

#### 注意
1. 需要两个词典: 储存邻接表 和 单词是否被遍历过. **不一定!!! 可以合为一个**
2. endWord 一定要在 [wordlist] 才有路径. 

#### 复杂度分析
* 时间复杂度：O(nm). n: 单词长度; m:单词表中单词个数. (需要遍历 dpeth+1 层才行).  
* 空间复杂度：O(nm). 需要储存每个单词的n个通用状态 ; 以及队列长度最坏也是nm. 


### 法2: 双向广度优先搜索(Bidirectional Breadth First Search)
#### 思考
根据给定字典构造的图可能会很大. 则进行 BFS 时搜索空间会随着层数的增长呈指数级的增加.    
如果使用两个开头同时进行 BFS, 可以有效减少搜索空间(从而降低时间和空间复杂度). (脑补一下, 单向就是一个三角形, 双向就是等高的菱形).  一端 beginWord, 另一端  endWord. 每次从两端各扩展一个单词(nodes). 当两端都访问了同一顶点时就停止搜索. 

#### 算法(不同之处)
1. 从两个节点同时开始搜索.
2. 结束条件是某个单词(双向BFS的交点)被两边都访问了. 
3. 返回值就是 两边depth之和. 

#### 注意
1. 最好还是两端每次各访问一个节点, 要不然depth算的头疼
2. 除了储存邻接表的 dic 外, 还需要两个 dic 和分别储存双向遍历分别到达各个节点的深度.
3.  在py3中, 不可以用 `queue_beg = queue_end = collections.deque()` 这样的形式!!! 它们指向了同一个地址. 

#### 复杂度分析
* 精度同上. 但 假设深度 depth, 每个节点可以扩展出 k 个节点, 则单向BFS时间复杂度 k^d, 双向BFS时间复杂度 2*k^(d/2), 对于 [wordlist] 很长时就会很有效.

## 126
> **(注: 有空了看看答案为什么有不到100s的解法)**
### 思考 
比 127 难了不止一点点 . BFS + DFS. 
* BFS 创造从 beginword -> endword 的合法图 (同127)
* 在BFS扩展过程中可以储存每个节点(可能>=1)的 parents, 以便下一步操作 -- 回溯路径. (空间换时间)
* DFS搜索合法路径
* 在每一层可以有重复节点.[队列里同层不要删掉] (以防漏掉合法路径). e.g.:
![huahuajiang](https://wx3.sinaimg.cn/mw1024/006qmTkdly1g6t6oam4hwj30ib08i0uu.jpg)     
如果不能有重复节点, 就会漏掉一条合法路径. 

### 法1 :单向 BFS + DFS
#### 算法
1. 预处理, 建立词典储存邻接表
2. 单向 BFS 寻找是否存在合法路径, 并在遍历同时储存每个节点的子节点. 注: 同层节点可以多次遍历, 但一个节点不能在不同层遍历. 
3. 利用 BFS 时储存的父子关系 找 合法路径. 
4. DFS 没啥特点

### 法2 :双向 BFS + DFS
结合一下就ok. 


